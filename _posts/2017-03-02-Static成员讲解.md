---
layout: post
title:  "static静态变量的理解(转载)"
date:   2017-03-02 23:54:01 +0800
tag: C++
---



[转载：http://www.cnblogs.com/dongzhiquan/archive/2009/07/21/1994792.html](http://www.cnblogs.com/dongzhiquan/archive/2009/07/21/1994792.html)


------------
### static静态变量的理解


* 静态变量 类型说明符是static。


静态变量属于静态存储方式，其存储空间为内存中的静态数据区（在 静态存储区内分配存储单元），该区域中的数据在整个程序的运行期间一直占用这些存储空间（在程序整个运行期间都不释放），也可以认为是其内存地址不变，直 到整个程序运行结束（相反，而auto自动变量，即动态局部变量，属于动态存储类别，占动态存储空间，函数调用结束后即释放）。静态变量虽在程序的整个执 行过程中始终存在，但是在它作用域之外不能使用。

另外，属于静态存储方式的量不一定就是静态变量。 例如：外部变量虽属于静态存储方式，但不一定是静态变量，必须由 static加以定义后才能成为静态外部变量，或称静态全局变量。

所有的全局变量都是静态变量，而局部变量只有定义时加上类型修饰符static，才为局部静态变量。

静态变量可以在任何可以申请的地方申请，一旦申请成功后，它将不再接受其他的同样申请。

静态变量并不是说其就不能改变值，不能改变值的量叫常量。 其拥有的值是可变的 ，而且它会保持最新的值。说其静态，是因为它不会随着函数的调用和退出而发生变化。即上次调用函数的时候，如果我们给静态变量赋予某个值的话，下次函数调用时，这个值保持不变。


#### 一、静态局部变量：


* 1、 Static类内部变量同auto自动变量（即未加 Static 声明的局部变量）一样，是某个特定函数的局部变量，即只能在定义该变量的函数内使用该变量，2者作用域相同；两者的不同在于：auto自动变量会随着函数 被调用和退出而存在和消失，而static类局部变量不会，它不管其所在的函数是否被调用，都将一直存在；不过，尽管该变量还继续存在，但不能使用它。倘 若再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后留下的值。换言之，Static类型的内部变量是一种只能在某个特定函数中使用，但一 直占据存储空间的变量。

* 2、函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作（出现在函数内部的基本类型的的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。

* 3、静态局部变量的初始化表达式必须是一个常量或者常量表达式。即使局部静态变量定义时没有赋初值，系统会自动赋初值0（对数值型变量）或空字符（对字符变量）；静态变量的初始值为0。而对自动变量auto来说，如果不赋初值则它的值将是个不确定的值。

* 4、当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。虽然用全局变量也可以达到上述目的，但全局变量有时会造成意外的副作用，因此仍以采用局部静态变量为宜。

注：局部静态变量占用内存时间较长，并且可读性差，因此，除非必要，尽量避免使用局部静态变量。

example:
//考察静态局部变量的值。

```cpp
# include < stdio. h>

int f( int a)
{
    auto b = 0;
    static c = 3;

    b = b + 1;
    c = c+ 1;
    return ( a+ b+ c) ;
}

main( )
{
    int a = 2, i;

    for ( i = 0; i < 3; i + + )
        printf ( "%d\n" , f( a) ) ;
}
//求1~5的阶乘。

/*
由于f为静态变量，能在每次调用后保留其值并在下一次调用时继续使用，所以输出值成为累加的结果。若变量f说明为自动变量（去掉static），当main中多次调用factor时，f均赋初 值为1，故每次输出值均为1。
*/

# include < stdio. h>

long factor( int n)
{
    static long int f = 1; //static
    f * = n;
    return f;
}

main( )
{
    int i;
    for ( i = 1; i < = 5; i+ + )
        printf ( "%ld\n" , factor( i) ) ;
}

```

#### 二、静态全局变量

全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。
全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。
这两者在存储方式上并无不同。


* 这两者的区别虽在于：

1、非静态全局变量的作用域是整个源程序 ，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。

2、静态全局变量则限制了其作用域， 即只在定义该变量的源文件 内有效，在同一源程序的其它源文件(即声明了该变量的CPP文件,或包含该变量声明头文件的CPP文件)中不能使用它。

由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

从以上分析可以看出————
把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。
把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。

因此static这个说明符在不同的地方所起的作用是不同的。应予以注意。

* 关于Static关键字
1.静态变量，分配在静态存储区，在数据段中。函数退出之后，变量值不变。
2.作用域，全局的静态变量、静态函数只能在本文件中使用。（不同于一般全局变量）
局部的静态变量同函数的局部变量



#### 五大内存分区(貌似与编译原理中不一样,不过道理是一样的,实际存在的东西总是会与理论有一定差距的)
* 1.在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

* 2.栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。

* 3.堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

* 4.自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

* 5.全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

* 6.常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）

另外：

1)、static静态变量会被放在程序的全局存储区中（即在程序的全局数据区，而不是在堆栈中分配，所以不会导致堆栈溢出），这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。

2)、static静态变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。——有信息隐蔽的作用。 （外部的 Static声明亦可用于声明函数。如果将函数声明为Static类型，则该函数名除了对该函数声明所在的文件可见外，其他文件均无法访问。 ）

3)、若全局变量仅在单个C文件中访问，则可将此变量改为静态全局变量，以降低模块间的耦合度；
若全局变量仅由单个函数访问，则可将此变量改为该函数的静态局部变量，以降低模块间的耦合度。


4)、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题。
所谓"可重入"（也可以说是可预测的），即：只要输入数据相同就应产生相同的输出。
函数中使用了static变量，因为static变量的特征，这样的函数被称为：带“内部存储器”功能的的函数。
如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量，这种函数中的static变量，使用原则是，能不用尽量不用。
当然，有些时候，在函数中是必须要使用static变量的，比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。
